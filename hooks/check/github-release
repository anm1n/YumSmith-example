#!/usr/bin/env bash
set -euo pipefail

usage() {
  echo "用法: $0 -p <项目目录>"
  exit 1
}

# 解析参数
while getopts ":p:" opt; do
  case $opt in
  p) project_dir="$OPTARG" ;;
  *) usage ;;
  esac
done

if [[ -z "${project_dir:-}" ]]; then
  usage
fi

# 检查配置文件
config_file=""
if [[ -f "$project_dir/config.yaml" ]]; then
  config_file="$project_dir/config.yaml"
elif [[ -f "$project_dir/config.yml" ]]; then
  config_file="$project_dir/config.yml"
else
  echo "错误: $project_dir 中未找到 config.yaml 或 config.yml" >&2
  exit 1
fi

# 遍历 source 列表
count=$(yq '.source | length' "$config_file")
tmp_config=$(mktemp)
cp "$config_file" "$tmp_config"

for ((i = 0; i < count; i++)); do
  url=$(yq -r ".source[$i].url" "$tmp_config")

  # 检查是否是 GitHub URL
  if [[ "$url" =~ ^https://github\.com/([^/]+)/([^/]+) ]]; then
    owner="${BASH_REMATCH[1]}"
    repo="${BASH_REMATCH[2]}"

    # 获取最新 release 信息
    release_json=$(gh api "repos/${owner}/${repo}/releases/latest")

    # 提取版本号（去掉前导 v）
    raw_tag=$(echo "$release_json" | jq -r '.tag_name')
    version="${raw_tag#v}"

    regex=$(yq -r ".source[$i].regex" "$tmp_config")

    if [[ "$regex" != "null" && -n "$regex" ]]; then
      # 用 regex 匹配 release 资产
      asset_url=$(echo "$release_json" | jq -r --arg re "$regex" '.assets[] | select(.name | test($re)) | .browser_download_url' | head -n1)
    else
      # 默认使用自动打包的 source tarball
      asset_url="https://github.com/${owner}/${repo}/archive/refs/tags/${raw_tag}.tar.gz"
    fi

    if [[ -z "$asset_url" ]]; then
      echo "警告: 未找到匹配的文件 ($owner/$repo)" >&2
      continue
    fi

    # 下载并计算 sha256
    tmpfile=$(mktemp)
    curl -sL "$asset_url" -o "$tmpfile"
    sha256=$(sha256sum "$tmpfile" | awk '{print $1}')
    rm -f "$tmpfile"

    # 更新配置文件
    yq -i ".source[$i].url = \"$asset_url\"" "$tmp_config"
    yq -i ".source[$i].sha256sum = \"$sha256\"" "$tmp_config"
  fi
done

# 覆盖原配置文件
mv "$tmp_config" "$config_file"

echo "配置文件已更新: $config_file"

project_name=$(basename "$project_dir")
specfile=${project_dir}/${project_name}.spec

if [ -e "$specfile" ]; then
  # 只替换 Version: 后的纯版本号部分，保留尾随的宏
  sed -i -E "s/^(Version:[[:space:]]*)[0-9][^[:space:]%}]*/\1${version}/" "$specfile" && echo "$specfile Version updated"

  # 重置 Release 为 1（同样保留可能的宏）
  sed -i -E "s/^(Release:[[:space:]]*)[0-9][^[:space:]%}]*/\11/" "$specfile" && echo "$specfile Release updated"
else
  echo "Error: $specfile not found"
fi
